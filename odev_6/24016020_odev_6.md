ROS Nedir? (Robot Operating System)
- ROS, robot yazılımı geliştirmeyi kolaylaştıran açık kaynaklı bir sistemdir. ROS'un çalışma mantığı, devasa bir program yazmak yerine, işi küçük parçalara bölüp bunları birbirine bağlamaya dayanır.

ROS'un çalışma mantığının yapı taşları hakkında bahsedelim:

1. Düğümler (Nodes)
    - Her node, farklı işlevli birer programdır.
    - Node'larla yapmamızın, tek bir kod üzerine yapmamızın nedeni; tek bir kod üzerine yapmış olsaydık ve bir hata çıksaydı tüm sistem çökerdi. Bunun önüne geçebilmek için bu sistem kullanılıyor.

2. Konular (Topics)
    - Node'ların birbiriyle haberleşmesi, veri ve bilgi aktarımı Topic denilen kanallarla gerçekleşir. Bu sistem Yayıncı/Abone mantığıyla çalışır.

    Publisher: Veriyi gönderen düğüm
    Subscriber: Veriyi alan düğüm

3. Mesajlar (Messages)
    - Topic'ler üzerinden gönderilen verilerin formatıdır. 

4. Servisler (Services)
    - Topic'ler üzerinden gönderilen verilerin akışı içersinde bir düğüm diğerinden feedback bekler, dolayısıyla servisler soru-cevap şeklinde çalışır.

5. Actions (Eylemler)
    - Servislerin gelişmiş halleridir ve daha uzun süren görevler için kullanılır.

6. Parametre Sunucusu (Parameter Server)
    - Robotun değişmeyen veya nadir değişen ayarlarının tutulduğu ortak bir havuzdur. Node'lar bilgiye ihtiyaç halinde bu havuzdan bilgi çeker.


ROS-1 ve ROS-2 Farklılıkları:

ROS-1:
    - Uzun zamandır kullanılan, kararlı ancak günümüz teknolojileri için güvenlik ve gerçek zamanlı sistemlerde açıklar yaratan versiyondur.

ROS-2:
    - Endüstriyel ihtiyaçlar, çoklu robot iletişimi ve yüksek güvenlik için geliştirilen modern versiyondur.


ROS'un kullanım alanları:
    ROS'un birçok alanda kullanıldığını görmekteyiz. Birkaç örnek vermek gerekirse:
        1. Otonom araçlar, otonom sürüş: Farklı sensörlerden gelen bilgileri birleştirip araçların etrafındaki nesne ve canlıları algılamasını sağlamak için ROS kullanılır. Autoware, otonom sürüş için ROS tabanlı geliştirilmiş dünyanın ilk açık kaynaklı yazılımıdır.

        2. İHA'lar: Droneların otonom uçuş yapması, belirli bir rotayı takip etmesi ve sürü (swarm) halinde hareket etmesi için ROS tercih edilir. Mavros adı verilen paket, PX4 ve ArduPilot gibi otopilot sistemleri ile ROS arasında bağlantı kurarak yüksek zorluklu görevlerin yapılmasını sağlar.

        3. İnsansı robotlar: Robotun denge kontrolü, yürüme algoritmaları ve insanlarla etkileşimi (konuşma tanıma, yüz takibi) ROS üzerinden yönetilir.

        4. Otonom robotlar: Depolarda paket taşıyan robotlar veya sokaklarda teslimat yapan araçlar ROS'un en çok kullanıldığı alanlardır. ROS içindeki Nav2 sayesinde robotun engellere çarpmadan rotasını çizmesi sağlanır.


ROS'un İHA'lardaki Rolü:
    - ROS, İHA'nın beynini oluşturur. Temel rolleri:

        1. Karar Mekanizması
            - Rota Planlama: ROS, İHA'nın etrafındaki engellerle etkileşime geçmeden hedefe ulaşması için rota çizer.
            - Sürü (Swarm) Operasyonları: Birden fazla drone'un birbirinin konumunu bilerek çarpışmadan koordineli uçmasını sağlar.
        
        2. Sensör Füzyonu ve Algılama:
            - ROS, İHA sensörlerinden alınan verileri işler.

        3. GPS Olmayan Ortamlarda Uçuş (Slam & VIO)
            - Standart İHA'lar GPS sinyali kesildiğinde yollarını kaybederler. ROS şu imkanları sağlar:
                a. Visual Inertial Odometry (VIO): Kamera görüntülerini analiz ederek drone'un ne kadar yer değiştirdiğini hesaplar.
                b. Indoor Navigation: Depo veya tünel gibi kapalı alanlarda harita çıkararak otonom uçuş yapmayı sağlar.
        
        4. Donanım Bağımsız Geliştirme:
            - Bu sistem bir büyük bir avantajdır. ROS'un mesaj yapısı sayesinde engelden kaçınma kodlarınızı küçük değişiklikler yaparak farklı bir uçuş kartına entegre edebiliriz.

        5. Simülasyon ve Test Ortamı: 
            - İHA projelerinde gerçek hayatlı bir test yaptığınızda drone'a zarar gelebilir. ROS, bu durumu ortadan şu şekilde kaldırır:
                - SITL (Software In The Loop): Projenizi, Gazebo veya AirSim gibi fiziksel motorlara sahip simülatörlerde test edebiliriz. Diğer farklı parametreleri de sanal ortamlarda test ederek geliştirebiliriz.

----------------------------------------------------------------------------------------------------------------------------------

MyTurtleSim ve öğrendiklerim:

Ubuntu kurmadan website üzerinden sanal bir şekilde yaptım, en yakın zamanda düzgün şartlar altında ubuntuyu kuracağım.

1- Workspace
    Projemizin yer alacağı çalışma alanını bu bölümde oluşturuyoruz. İçerisinde source klasörü bizim bütün fonksiyonları içeren dosyamız olacak. Bunun için terminale Github eğitimden de öğrendiğimiz mkdir (klasör oluşturma) kodunu yazıyoruz.

2- Paket oluşturma 
    "ros2 pkg create --build-type ament_python my_turtle_controller --dependencies rclpy geometry_msgs0"
    Yazdığım bu kodla birlikte my_turtle_controller adında bir ros2 paketi oluşturduk, kodun python dili ile yazılacağını(build-type), yazılırken kullanılacak kütüphaneleri tanımladık(dependencies).

3- Python kod analizi

    a. "import rclpy
    from rclpy.node import Node
    from geometry_msgs.msg import Twist"

    Öncelikle node ve twist kütüphanesini ekledik. Twist, kaplumbağanın dairesel yörünge çizmesi için ihtiyaç duyulan düz ve açısal hızların verisini tutar.

    b. "class TurtleMover(Node):
        def __init__(self):
        super().__init__('turtle_mover_node')"

    TurtleMover isminde bir sınıf oluşturduk.

    c. "self.publisher_ = self.create_publisher(Twist, '/turtle1/cmd_vel', 10)"

    Publisher, hatırladığımız üzere verileri gönderen kaynak olarak düşünebiliriz. Dairesel yörünge için düz ve açısal hız verisini tutan twist veri tipini kullanarak yayınlar, kaplumbağa ise subscriber'dır ve verileri alır. Kodun sonundaki 10 sayısı son 10 veriyi baz almasını sağlar.

    d. "timer_period = 0.5
        self.timer = self.create_timer(timer_period, self.timer_callback)"

    Kaplumbağaya her 0.5 saniyede bir hareket etme emrini vermek için zamanlayıcı kullanıyoruz.

    e. "def timer_callback(self):
        msg = Twist()
        msg.linear.x = 2.0
        msg.angular.z = 1.0
        self.publisher_.publish(msg)"

    Boş bir hız mesajı oluşturup düz olarak 2 açısal olarak 1 birimlik ilerlemeler kaydettiriyoruz ve bunu her 0.5 saniyede bir kaplumbağaya göndererek tekrarlıyoruz. 

    f. entry_points Düzenlemesi
    
    'console_scripts': [
    'mover = my_turtle_controller.turtle_mover:main',] düzenlemesi
    
    Yazdığımız uzun kaplumbağa döndürme kodunu çalıştırmak adına kodun bulunduğu main fonksiyonunu tanımlama işlemi.

    g. Ek terminal ve ek işlemler

    colcon build: Yazdığımız kodları, ayar dosyalarını derleyerek ROS sisteminin anlayacağı, çalıştırılabilir bir paket haline getirir. Install klasörünü oluşturur.

    source install/setup.bash: Terminalin yeni oluşturduğumuz paketten haberdar olmasını sağlar.

    ros2 run my_turtle_controller mover: Simülasyon ortamına geçiş kodu. run node'unu my_turtle_controller paketiyle mover adlı programı çalıştıran kod.


